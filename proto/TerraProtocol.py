# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: terraprotocol.proto
# plugin: python-betterproto
from dataclasses import dataclass
from typing import List

import betterproto


class ExpressionInstructions(betterproto.Enum):
    CONST = 0
    VAR = 1
    AND = 2
    OR = 3
    NOT = 4
    LT = 5
    GT = 6
    EQ = 7
    ADD = 8
    SUB = 9
    MUL = 10
    DIV = 11
    MOD = 12
    LOG = 13
    POW = 14
    SQRT = 15
    EXP = 16
    CEIL = 17
    FLOOR = 18
    ROUND = 19
    ABS = 20
    LTEQ = 21
    GTEQ = 22


class WindowAggregationType(betterproto.Enum):
    MIN = 0
    MAX = 1
    SUM = 2
    AVG = 3
    COUNT = 4


@dataclass
class Data(betterproto.Message):
    instruction: "ExpressionInstructions" = betterproto.enum_field(1, group="data")
    _uint8: int = betterproto.uint32_field(2, group="data")
    _uint16: int = betterproto.uint32_field(3, group="data")
    _uint32: int = betterproto.uint32_field(4, group="data")
    # uint64 _uint64 = 5;
    _int8: int = betterproto.sint32_field(6, group="data")
    _int16: int = betterproto.sint32_field(7, group="data")
    _int32: int = betterproto.sint32_field(8, group="data")
    # sint64 _int64 = 9;
    _float: float = betterproto.float_field(10, group="data")
    _double: float = betterproto.double_field(11, group="data")


@dataclass
class Output(betterproto.Message):
    responses: List["OutputQueryResponse"] = betterproto.message_field(1)


@dataclass
class OutputQueryResponse(betterproto.Message):
    id: int = betterproto.int32_field(1)
    response: List["Data"] = betterproto.message_field(2)


@dataclass
class Expression(betterproto.Message):
    instructions: List["Data"] = betterproto.message_field(1)


@dataclass
class MapOperation(betterproto.Message):
    function: "Expression" = betterproto.message_field(1)
    attribute: int = betterproto.int32_field(2)


@dataclass
class FilterOperation(betterproto.Message):
    predicate: "Expression" = betterproto.message_field(1)


@dataclass
class Aggregation(betterproto.Message):
    aggregation_type: "WindowAggregationType" = betterproto.enum_field(1)
    on_attribute: int = betterproto.int32_field(2)
    as_attribute: int = betterproto.int32_field(3)


@dataclass
class TumblingWindowOperation(betterproto.Message):
    size_ms: int = betterproto.int32_field(1)


@dataclass
class SlidingWindowOperation(betterproto.Message):
    size_ms: int = betterproto.int32_field(1)
    slide_ms: int = betterproto.int32_field(2)


@dataclass
class ThresholdWindowOperation(betterproto.Message):
    predicate: "Expression" = betterproto.message_field(1)
    minimum_size: int = betterproto.int32_field(2)


@dataclass
class WindowOperation(betterproto.Message):
    aggregation: "Aggregation" = betterproto.message_field(1)
    tumbling: "TumblingWindowOperation" = betterproto.message_field(
        2, group="WindowOperation"
    )
    sliding: "SlidingWindowOperation" = betterproto.message_field(
        3, group="WindowOperation"
    )
    threshold: "ThresholdWindowOperation" = betterproto.message_field(
        4, group="WindowOperation"
    )


@dataclass
class Operation(betterproto.Message):
    map: "MapOperation" = betterproto.message_field(1, group="operation")
    filter: "FilterOperation" = betterproto.message_field(2, group="operation")
    window: "WindowOperation" = betterproto.message_field(3, group="operation")


@dataclass
class Query(betterproto.Message):
    # bytes resultType = 2; //For some reason minipb breaks if I make this a
    # repeated enum or int32
    operations: List["Operation"] = betterproto.message_field(1)


@dataclass
class Message(betterproto.Message):
    queries: List["Query"] = betterproto.message_field(1)
